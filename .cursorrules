# Cursor Rules for Salmon Run Scenario Hub

このファイルは、CursorエディタのAIアシスタントがこのプロジェクトで作業する際のルールとガイドラインを定義します。

## プロジェクト概要

Salmon Run Scenario Hubは、Next.js 16 (App Router)、TypeScript、Tailwind CSS、Supabaseを使用したWebアプリケーションです。

## 技術スタック

- Next.js 16.0.10 (App Router)
- TypeScript 5.3.0
- Tailwind CSS 3.4.0
- Supabase (Auth, Database)
- Vitest 1.1.0 (テスト)
- React Testing Library 14.1.2
- ESLint 9.0.0
- Docker

## コーディング規約

### TypeScript

- 厳格モード（strict: true）を使用
- `any`の使用は避ける
- 型定義は明示的に記述
- Supabaseの`Database`型を活用

### ファイル命名

- コンポーネント: PascalCase (例: `UserProfile.tsx`)
- ユーティリティ: camelCase (例: `google-auth.ts`)
- テスト: `*.test.ts` または `*.test.tsx`

### インポート順序

1. React / Next.js
2. サードパーティライブラリ
3. 内部モジュール（`@/`エイリアス）
4. 型定義

## Next.js 16の重要な変更点

### 1. proxy.ts

- `middleware.ts`ではなく`proxy.ts`を使用
- 関数名は`proxy`（`middleware`ではない）

### 2. 非同期cookies()

```typescript
// 正しい
const cookieStore = await cookies()

// 間違い
const cookieStore = cookies()
```

### 3. Supabase SSR API

```typescript
// 新しいAPI（正しい）
cookies: {
  getAll() {
    return cookieStore.getAll()
  },
  setAll(cookiesToSet) {
    cookiesToSet.forEach(({ name, value, options }) =>
      cookieStore.set(name, value, options)
    )
  },
}

// 古いAPI（非推奨）
cookies: {
  get(name: string) { ... },
  set(name: string, value: string, options: CookieOptions) { ... },
  remove(name: string, options: CookieOptions) { ... },
}
```

## 認証パターン

### クライアントコンポーネント

```typescript
'use client'
import { signInWithGoogle } from '@/lib/auth/google-auth'
```

### サーバーコンポーネント

```typescript
import { createClient } from '@/lib/supabase/server'

// awaitが必要
const supabase = await createClient()
const { data: { user } } = await supabase.auth.getUser()
```

## テスト

- Vitestを使用（Jestではない）
- テストファイルは`__tests__`ディレクトリに配置
- `@testing-library/jest-dom`のマッチャーを使用
- モックは`vi.mock()`を使用

### テスト作成時の留意事項

#### 1. グローバルオブジェクトのモック

**`navigator.clipboard`のモック**:
- `navigator.clipboard`は読み取り専用プロパティのため、直接代入できない
- `Object.defineProperty`を使用してモックする
- `beforeEach`で毎回再設定する

```typescript
const mockWriteText = vi.fn().mockResolvedValue(undefined)

beforeEach(() => {
  Object.defineProperty(global.navigator, 'clipboard', {
    value: {
      writeText: mockWriteText,
    },
    writable: true,
    configurable: true,
  })
})
```

#### 2. fetchモックの設定

**初期データ取得とテスト対象リクエストの両方に対応**:
- コンポーネントのマウント時に実行される初期データ取得用のfetchと、テスト対象のリクエスト用のfetchの両方に対応する
- URLやメソッドで条件分岐して適切なレスポンスを返す

```typescript
global.fetch = vi.fn((url: string, options?: any) => {
  // テスト対象のリクエスト
  if (options?.method === 'POST' && url.includes('/api/endpoint')) {
    return Promise.resolve({
      json: async () => ({ success: true, data: {} }),
    })
  }
  // 初期データ取得用のリクエスト
  if (url.includes('/api/initial-data')) {
    return Promise.resolve({
      json: async () => ({ success: true, data: mockData }),
    })
  }
  return Promise.resolve({
    json: async () => ({ success: true, data: {} }),
  })
})
```

#### 3. 要素の取得方法

**labelとinputの関連付けがない場合**:
- `getByLabelText`は`for`属性や`aria-labelledby`で関連付けられている必要がある
- 関連付けがない場合は`getByRole('textbox')`や`getAllByRole('textbox')`を使用

```typescript
// labelとinputが関連付けられていない場合
const textboxes = screen.getAllByRole('textbox')
const nameInput = textboxes[0]
```

**複数の要素に同じテキストが存在する場合**:
- `getByText`の代わりに`getAllByText`を使用
- または、より具体的なセレクタ（`getByRole`, `getByTestId`など）を使用

```typescript
// 複数の要素に同じテキストが存在する場合
const elements = screen.getAllByText('テキスト')
expect(elements.length).toBeGreaterThan(0)
```

#### 4. 非同期処理の待機

**非同期処理が完了するまで待つ**:
- `waitFor`を使用して非同期処理の完了を待つ
- タイムアウトを適切に設定する（デフォルトは1000ms）

```typescript
await waitFor(
  () => {
    expect(mockFunction).toHaveBeenCalledWith(expectedArgs)
  },
  { timeout: 3000 }
)
```

#### 5. Material-UIコンポーネントのモック

**Material-UIコンポーネントをモックする場合**:
- `multiple`プロパティなど、コンポーネントの全プロパティに対応する
- `renderInput`などのコールバック関数も適切に処理する

```typescript
vi.mock('@mui/material', () => ({
  Autocomplete: ({ options, value, onChange, renderInput, multiple, ...props }: any) => {
    // multipleプロパティにも対応
    return (
      <div data-testid="autocomplete">
        <select
          multiple={multiple}
          onChange={(e) => {
            // onChange処理
          }}
        >
          {options.map((opt: any) => (
            <option key={opt.id} value={opt.id}>{opt.name}</option>
          ))}
        </select>
        {renderInput && renderInput({})}
      </div>
    )
  },
}))
```

#### 6. 画像のalt属性での検索

**画像要素の検索**:
- 武器名などが画像の`alt`属性に存在する場合は、`getByAltText`を使用
- `getByText`では見つからない場合がある

```typescript
// 画像のalt属性で検索
expect(screen.getByAltText('スプラシューター')).toBeInTheDocument()
```

#### 7. テストの独立性

**各テストは独立して実行できるようにする**:
- `beforeEach`でモックをクリアし、初期状態にリセットする
- グローバルオブジェクトのモックも`beforeEach`で再設定する

```typescript
beforeEach(() => {
  vi.clearAllMocks()
  mockFunction.mockClear()
  // グローバルオブジェクトのモックも再設定
  Object.defineProperty(global.navigator, 'clipboard', {
    value: { writeText: mockWriteText },
    writable: true,
    configurable: true,
  })
})
```

#### 8. ファイル入力要素の取得

**labelとinputの関連付けがない場合**:
- Material-UIの`Button`コンポーネントが`component="label"`として使用されている場合、`getByLabelText`では取得できない
- `document.querySelector('input[type="file"]')`で直接取得する

```typescript
// labelとinputが関連付けられていない場合
const input = document.querySelector('input[type="file"]') as HTMLInputElement
expect(input).toBeInTheDocument()
await user.upload(input, file)
```

#### 9. エラーメッセージと成功メッセージの検証

**非同期で表示されるメッセージの検証**:
- `getByText`の代わりに`queryByText`を使用し、`waitFor`で適切に待機する
- タイムアウト時間を適切に設定する（デフォルトは1000ms）

```typescript
// エラーメッセージの検証
await waitFor(
  () => {
    const errorMessage = screen.queryByText('エラーメッセージ')
    expect(errorMessage).toBeInTheDocument()
  },
  { timeout: 3000 }
)
```

#### 10. ファイルアップロードのテスト

**ファイルアップロードのテスト**:
- `user.upload`が正しく動作しない場合は、直接イベントを発火する
- ファイルの型チェックやサイズチェックのテストでは、`Object.defineProperty`でファイルを設定してからイベントを発火する

```typescript
// ファイルを直接設定してonChangeイベントを発火
const file = new File(['test'], 'test.txt', { type: 'text/plain' })
const input = document.querySelector('input[type="file"]') as HTMLInputElement

Object.defineProperty(input, 'files', {
  value: [file],
  writable: false,
  configurable: true,
})

// ChangeEventを作成して発火
const changeEvent = new Event('change', { bubbles: true }) as any
Object.defineProperty(changeEvent, 'target', {
  value: input,
  enumerable: true,
})
input.dispatchEvent(changeEvent)
```

#### 11. フォーム送信のテスト

**フォームのsubmitイベントのテスト**:
- Material-UIの`Button`コンポーネントが`type="submit"`の場合、`user.click`でボタンをクリックしてもフォームの`onSubmit`が発火しない場合がある
- フォームの`submit`イベントを直接発火する

```typescript
// フォーム要素を取得
const form = screen.getByText('保存する').closest('form') as HTMLFormElement
expect(form).toBeInTheDocument()

// フォームのsubmitイベントを直接発火
const submitEvent = new Event('submit', { bubbles: true, cancelable: true })
const preventDefaultSpy = vi.fn()
Object.defineProperty(submitEvent, 'preventDefault', {
  value: preventDefaultSpy,
  writable: true,
})
form.dispatchEvent(submitEvent)
```

#### 12. global.fetchのモック

**テスト内でglobal.fetchを上書きする場合**:
- `beforeEach`で設定された`global.fetch`と、テスト内で設定された`global.fetch`が競合する可能性がある
- テスト内で`global.fetch`を上書きする場合は、元のモックを保存してから上書きし、テスト終了時に復元する
- URLの型が`string | URL | Request`の可能性があるため、適切に処理する

```typescript
it('should handle save scenario', async () => {
  // 元のfetchを保存
  const originalFetch = global.fetch
  
  // fetchモックを設定
  const fetchMock = vi.fn((url: string | URL | Request, options?: any) => {
    const urlString = typeof url === 'string' ? url : url instanceof URL ? url.toString() : url.url
    // モック処理
  })
  
  global.fetch = fetchMock
  
  // テスト実行
  
  // 元のfetchを復元
  global.fetch = originalFetch
})
```

#### 13. タイムアウト時間の設定

**長時間実行されるテスト**:
- 非同期処理が多いテストや、複数のAPI呼び出しを含むテストでは、タイムアウト時間を適切に設定する
- テスト全体のタイムアウトを設定する場合は、`it`の第2引数にタイムアウト時間を指定する

```typescript
it('should handle save scenario', async () => {
  // テストコード
}, 15000) // テスト全体のタイムアウトを15秒に設定

// または、waitForのタイムアウトを個別に設定
await waitFor(
  () => {
    expect(someCondition).toBe(true)
  },
  { timeout: 10000 }
)
```

#### 14. fetchモックの呼び出し確認

**fetchモックが正しく呼ばれたことを確認する**:
- `fetchMock.mock.calls`を確認する際は、URLの型が`string | URL | Request`の可能性があるため、適切に処理する
- 複数のAPI呼び出しがある場合は、URLやメソッドでフィルタリングする

```typescript
// fetchMockが呼ばれたか確認
const saveCalls = fetchMock.mock.calls.filter(
  (call) => {
    const url = typeof call[0] === 'string' ? call[0] : call[0] instanceof URL ? call[0].toString() : call[0]?.url || ''
    const options = call[1] || {}
    return url.includes('/api/scenarios') && !url.includes('/check') && options.method === 'POST'
  }
)
expect(saveCalls.length).toBeGreaterThan(0)
```

## エラーハンドリング

```typescript
try {
  await someAsyncOperation()
} catch (error) {
  if (error instanceof Error) {
    console.error(error.message)
    // ユーザーに適切なエラーメッセージを表示
  }
}
```

## 環境変数

- `.env.local`に設定（Gitにコミットしない）
- `NEXT_PUBLIC_`プレフィックスが必要（クライアント側で使用）

## 禁止事項

- `middleware.ts`の使用（`proxy.ts`を使用）
- 同期的な`cookies()`の使用（`await cookies()`を使用）
- 古いSupabase SSR APIの使用（`getAll()` / `setAll()`を使用）
- `any`型の使用（可能な限り避ける）

## 推奨事項

- 小さなコンポーネントに分割
- サーバーコンポーネントを優先
- 新機能には必ずテストを追加
- 型安全性を重視
- エラーハンドリングを実装

## 必須の前提条件（Issue対応時）

**重要**: Issueに対応する際は、以下の手順を必ず全て実施してください。これらは必須であり、漏れなく実行する必要があります。

### 1. 作業ブランチの作成

- Issueに対応する適切な作業ブランチを作成すること
- ブランチ名は `feature/issue-{番号}-{簡潔な説明}` または `fix/issue-{番号}-{簡潔な説明}` の形式を推奨
- 例: `feature/issue-12-scenario-detail-social`, `fix/issue-5-login-error`

### 2. Issue内容の確認と実装

- Issueの`概要`と`詳細`の内容を必ず読み取り、記述内容の条件を全て対応すること
- Issueに記載されている要件を漏れなく実装すること
- 不明な点がある場合は、Issueにコメントで確認すること

### 3. テストの作成

- コード修正時、対応するテストも必ず作成すること
- 新機能には必ずテストを追加すること
- 既存機能の修正時は、既存のテストを更新し、必要に応じて新しいテストを追加すること
- テストカバレッジ80%以上を維持すること

### 4. ESLintチェック

- ESLintによるチェックを必ず実行すること
- `npm run lint`を実行し、エラーがないことを確認すること
- エラーがある場合は、`npm run lint:fix`で自動修正を試み、残りのエラーは手動で修正すること

### 5. 脆弱性チェック（push前）

- GitHubへのpush前に、依存関係の脆弱性チェックを必ず実行すること
- `npm run audit`を実行し、重大な脆弱性（high以上）がないことを確認すること
- 脆弱性が発見された場合は、`npm run audit:fix`で自動修正を試みるか、手動で対応すること
- 重大な脆弱性が残っている場合は、push前に必ず修正すること（CIでビルドが失敗するため）

### 6. コードレビュー（push前）

- コード修正後、pushする前に今回の変更をレビューし、発見された問題を全て修正してからpushすること
- 以下の観点でレビューを実施すること：
  - コードの品質（可読性、保守性）
  - 型安全性（TypeScriptの型エラーがないか）
  - エラーハンドリングが適切か
  - テストが適切に実装されているか
  - 不要なコードやコメントがないか
  - セキュリティ上の問題がないか
- `git diff`や`git status`を確認し、意図しない変更が含まれていないことを確認すること

### 7. Pull Requestの作成

- `gh`コマンドを利用し、Pull Requestを作成すること
- Pull Request内の言語は**日本語**で記述すること
- Pull Requestには変更内容に応じて処理シーケンスなどを**mermaid形式**で記述すること
- 指定されたIssue番号を必ず記述すること（例: `Closes #12`, `Fixes #5`）

#### Pull Requestのテンプレート例

```markdown
## 概要
[変更内容の簡潔な説明]

## 変更内容
- [変更点1]
- [変更点2]

## 処理フロー

\`\`\`mermaid
sequenceDiagram
    participant User
    participant App
    participant Supabase
    
    User->>App: 操作
    App->>Supabase: リクエスト
    Supabase-->>App: レスポンス
    App-->>User: 結果表示
\`\`\`

## テスト
- [ ] 単体テストを追加
- [ ] 統合テストを実行
- [ ] 手動テストを実施

## 関連Issue
Closes #12
```

**注意**: Pull Request説明ファイルは`docs/pr-descriptions/`ディレクトリに格納されています。`gh pr create`コマンドで`--body-file`オプションを使用する際は、以下のようにパスを指定してください：

```bash
gh pr create --title "タイトル" --body-file docs/pr-descriptions/PR_DESCRIPTION_ISSUE*.md --base main
```

### 8. AIエージェント向けドキュメントの更新

- GEMINIやClaudeが変更内容を適切にトレースできるよう、必要に応じて以下のファイルを修正すること：
  - `GEMINI.md` - 新機能や設計変更を反映
  - `CLAUDE.md` - アーキテクチャやパターンの変更を反映
- 新機能追加時、API変更時、アーキテクチャ変更時は必ず更新すること

### 作業フローのチェックリスト

Issue対応時は、以下のチェックリストを確認してください：

- [ ] Issueに対応する適切な作業ブランチを作成した
- [ ] Issueの`概要`と`詳細`の内容を読み取り、全ての条件に対応した
- [ ] コード修正時、対応するテストを作成した
- [ ] ESLintによるチェックを実行し、エラーがないことを確認した
- [ ] 脆弱性チェックを実行し、重大な脆弱性がないことを確認した
- [ ] コード修正後、pushする前に今回の変更をレビューし、発見された問題を全て修正した
- [ ] `gh`コマンドを利用し、Pull Requestを作成した
- [ ] Pull Request内の言語は日本語で記述した
- [ ] Pull Requestに処理シーケンスなどをmermaid形式で記述した
- [ ] 指定されたIssue番号を記述した
- [ ] 必要に応じて`GEMINI.md`と`CLAUDE.md`を修正した

## CI/CD

このプロジェクトでは、GitHub Actionsを使用してCI/CDパイプラインを構築しています。

### ワークフロー一覧

1. **CI Workflow** (`.github/workflows/ci.yml`)
   - トリガー: `main`/`staging`へのpush、PR
   - 実行内容: セキュリティ監査、Lint、テスト、カバレッジレポートのアップロード
   - 必要なSecrets: `CODECOV_TOKEN`

2. **Docker Publish Workflow** (`.github/workflows/docker-publish.yml`)
   - トリガー: `main`ブランチへのpush
   - 実行内容: Dockerイメージのビルドとpush（GitHub Container RegistryとDocker Hubの両方）
   - 必要なSecrets: `DOCKERHUB_USERNAME`, `DOCKERHUB_TOKEN`

3. **Sync Wiki Workflow** (`.github/workflows/sync-wiki.yml`)
   - トリガー: `main`ブランチへのpush（`docs-wiki/**`パスへの変更時）、または手動実行
   - 実行内容: `docs-wiki`サブモジュールの変更をGitHub Wikiに同期
   - 必要なSecrets: `WIKI_SYNC_TOKEN`

### ワークフロー実行時の注意事項

- CIワークフローは、プルリクエスト作成時と`main`/`staging`ブランチへのpush時に自動実行されます
- Docker Publishワークフローは、`main`ブランチへのpush時のみ実行されます
- Sync Wikiワークフローは、`docs-wiki/**`パスへの変更がある場合のみ実行されます
- 各ワークフローで必要なSecretsが設定されていることを確認してください

## ファイル構成

```
app/                    # Next.js App Router
lib/                    # 共有ライブラリ
  auth/                 # 認証ロジック
  supabase/             # Supabaseクライアント
proxy.ts               # リクエストミドルウェア
.github/workflows/     # GitHub Actionsワークフロー
  ci.yml               # CIワークフロー
  docker-publish.yml   # Dockerイメージビルド&プッシュ
  sync-wiki.yml        # Wiki同期ワークフロー
docs/                  # ドキュメント
  pr-descriptions/     # Pull Request説明ファイル
docs-wiki/             # ドキュメント（submodule）
```

## 参考ファイル

- `CLAUDE.md` - Claude AIエージェント向け詳細情報
- `GEMINI.md` - Gemini AIエージェント向け詳細情報
- `README.md` - プロジェクトの概要（CI/CDワークフローの詳細含む）
- `docs/pr-descriptions/` - Pull Request説明ファイル
- `docs-wiki/` - 詳細なドキュメント

