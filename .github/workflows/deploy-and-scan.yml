name: Deploy and Security Scan

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - main
  push:
    branches:
      - main

jobs:
  deploy-preview:
    runs-on: ubuntu-latest
    name: Deploy to Vercel Preview
    outputs:
      url: ${{ steps.deploy_preview.outputs.url }}
      environment: ${{ steps.deploy_preview.outputs.environment }}
    env:
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Pull Vercel Environment Information
        run: |
          vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Verify Vercel Configuration
        run: |
          # .vercelãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒä½œæˆã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
          if [ ! -d ".vercel" ]; then
            echo "Error: .vercel directory not found after vercel pull"
            exit 1
          fi
          
          # project.jsonãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
          if [ ! -f ".vercel/project.json" ]; then
            echo "Error: .vercel/project.json not found"
            exit 1
          fi
          
          # ç’°å¢ƒå¤‰æ•°ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
          ENV_FILES=$(find .vercel -name ".env.*" -type f | wc -l)
          if [ "$ENV_FILES" -eq 0 ]; then
            echo "Warning: No .env files found in .vercel directory"
          else
            echo "Found $ENV_FILES environment variable file(s)"
          fi
          
          echo "Vercel configuration verified successfully"
          echo "Project configuration:"
          cat .vercel/project.json

      - name: Build Project Artifacts
        run: |
          vercel build --token=${{ secrets.VERCEL_TOKEN }}

      - name: Deploy to Vercel Preview
        id: deploy_preview
        run: |
          DEPLOYMENT_OUTPUT=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }})
          echo "$DEPLOYMENT_OUTPUT"
          DEPLOYMENT_URL=$(echo "$DEPLOYMENT_OUTPUT" | grep -o 'https://[^ ]*\.vercel\.app' | head -1)
          
          if [ -z "$DEPLOYMENT_URL" ]; then
            echo "Error: Failed to extract deployment URL from Vercel output"
            exit 1
          fi
          
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "environment=preview" >> $GITHUB_OUTPUT
          echo "Deployment URL: $DEPLOYMENT_URL"

      - name: Comment PR with deployment URL
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const url = '${{ steps.deploy_preview.outputs.url }}';
            if (url) {
              const body = `ðŸš€ **Vercel Preview Deployment**\n\nðŸ”— Preview: ${url}\n\nThis deployment was created automatically by GitHub Actions.`;
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

  scan-preview:
    runs-on: ubuntu-latest
    name: OWASP ZAP Security Scan (Preview)
    needs: deploy-preview
    if: always() && needs.deploy-preview.result == 'success'
    outputs:
      scan_passed: ${{ steps.parse_results.outputs.scan_passed }}
      has_critical_issues: ${{ steps.parse_results.outputs.has_critical_issues }}
    permissions:
      contents: read
      issues: write
      pull-requests: write
      security-events: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate deployment URL
        id: validate_url
        env:
          TARGET_URL: ${{ needs.deploy-preview.outputs.url }}
        run: |
          if [ -z "$TARGET_URL" ]; then
            echo "Error: Deployment URL is empty"
            exit 1
          fi
          
          if [[ ! "$TARGET_URL" =~ ^https?:// ]]; then
            echo "Error: Invalid URL format: $TARGET_URL"
            exit 1
          fi
          
          echo "Deployment URL validated: $TARGET_URL"

      - name: Wait for deployment to be ready
        env:
          TARGET_URL: ${{ needs.deploy-preview.outputs.url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
        run: |
          echo "Waiting for Vercel deployment to be ready..."
          echo "Target URL: $TARGET_URL"
          MAX_RETRIES=30
          RETRY_COUNT=0
          WAIT_INTERVAL=15

          # Vercel Automation Bypassãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
          BYPASS_HEADER=""
          if [ -n "$VERCEL_AUTOMATION_BYPASS_SECRET" ]; then
            BYPASS_HEADER="-H \"x-vercel-protection-bypass: $VERCEL_AUTOMATION_BYPASS_SECRET\""
            echo "Using Vercel Automation Bypass header"
          else
            echo "Warning: VERCEL_AUTOMATION_BYPASS_SECRET is not set"
          fi

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if [ -n "$VERCEL_AUTOMATION_BYPASS_SECRET" ]; then
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -H "x-vercel-protection-bypass: $VERCEL_AUTOMATION_BYPASS_SECRET" "$TARGET_URL" || echo "000")
            else
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$TARGET_URL" || echo "000")
            fi
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Deployment is ready! HTTP Status: $HTTP_CODE"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "Connection failed (retry $RETRY_COUNT/$MAX_RETRIES)"
            else
              echo "HTTP Status: $HTTP_CODE (retry $RETRY_COUNT/$MAX_RETRIES)"
            fi
            
            sleep $WAIT_INTERVAL
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          echo "Error: Deployment did not become ready after $((MAX_RETRIES * WAIT_INTERVAL)) seconds"
          echo "Last HTTP Status: $HTTP_CODE"
          exit 1

      - name: Check if ZAP rules file exists
        id: check_zap_rules
        run: |
          if [ -f ".zap/rules.tsv" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ZAP rules file found: .zap/rules.tsv"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ZAP rules file not found: .zap/rules.tsv (will use default rules)"
          fi

      - name: Build ZAP cmd_options with header injection
        id: build_zap_options
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
        run: |
          BASE_OPTIONS="-a"
          
          if [ -n "$VERCEL_AUTOMATION_BYPASS_SECRET" ]; then
            # ZAPã®replaceræ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ³¨å…¥
            REPLACER_CONFIG="-z \"-config replacer.full_list(0).description=auth -config replacer.full_list(0).enabled=true -config replacer.full_list(0).matchtype=REQ_HEADER -config replacer.full_list(0).matchstr=x-vercel-protection-bypass -config replacer.full_list(0).replacement=$VERCEL_AUTOMATION_BYPASS_SECRET\""
            CMD_OPTIONS="$BASE_OPTIONS $REPLACER_CONFIG"
            echo "Using Vercel Automation Bypass header injection"
          else
            CMD_OPTIONS="$BASE_OPTIONS"
            echo "Warning: VERCEL_AUTOMATION_BYPASS_SECRET is not set, skipping header injection"
          fi
          
          echo "cmd_options=$CMD_OPTIONS" >> $GITHUB_OUTPUT
          echo "Built ZAP cmd_options: $CMD_OPTIONS"

      - name: ZAP Baseline Scan (with rules file)
        id: zap_scan_with_rules
        if: steps.check_zap_rules.outputs.exists == 'true'
        uses: zaproxy/action-baseline@v0.12.0
        continue-on-error: true
        with:
          target: ${{ needs.deploy-preview.outputs.url }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: ${{ steps.build_zap_options.outputs.cmd_options }}
          fail_action: false
          allow_issue_writing: false

      - name: ZAP Baseline Scan (without rules file)
        id: zap_scan_no_rules
        if: steps.check_zap_rules.outputs.exists == 'false'
        uses: zaproxy/action-baseline@v0.12.0
        continue-on-error: true
        with:
          target: ${{ needs.deploy-preview.outputs.url }}
          cmd_options: ${{ steps.build_zap_options.outputs.cmd_options }}
          fail_action: false
          allow_issue_writing: false

      - name: Check ZAP output files
        id: check_zap_files
        if: always()
        run: |
          echo "Checking for ZAP output files..."
          ls -la
          echo ""
          echo "Files matching *report*:"
          ls -la *report* 2>/dev/null || echo "No files matching *report* found"
          echo ""
          echo "Files matching report_*:"
          ls -la report_* 2>/dev/null || echo "No files matching report_* found"
          echo ""
          echo "Files matching zap_*:"
          ls -la zap_* 2>/dev/null || echo "No files matching zap_* found"
          
          # ZAPã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒç”Ÿæˆã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç¢ºèª
          if [ -f "report_json.json" ]; then
            echo "Found report_json.json, renaming to zap_report.json"
            cp report_json.json zap_report.json
          fi
          if [ -f "report_md.md" ]; then
            echo "Found report_md.md, renaming to zap_report.md"
            cp report_md.md zap_report.md
          fi
          if [ -f "report_html.html" ]; then
            echo "Found report_html.html, renaming to zap_report.html"
            cp report_html.html zap_report.html
          fi
          
          # SARIFãƒ•ã‚¡ã‚¤ãƒ«ã®ç¢ºèª
          if [ -f "zap_report.sarif" ]; then
            echo "sarif_exists=true" >> $GITHUB_OUTPUT
          elif [ -f "report.sarif" ]; then
            echo "Found report.sarif, renaming to zap_report.sarif"
            cp report.sarif zap_report.sarif
            echo "sarif_exists=true" >> $GITHUB_OUTPUT
          else
            echo "sarif_exists=false" >> $GITHUB_OUTPUT
          fi
          
          # JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ç¢ºèª
          if [ -f "zap_report.json" ]; then
            echo "json_exists=true" >> $GITHUB_OUTPUT
          else
            echo "json_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Archive ZAP results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-report-preview-${{ github.run_id }}
          path: |
            zap_report.html
            zap_report.json
            zap_report.md
            zap_report.sarif
            report_html.html
            report_json.json
            report_md.md
            report.sarif
          retention-days: 30
          if-no-files-found: ignore

      - name: Upload ZAP results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always() && steps.check_sarif.outputs.exists == 'true'
        continue-on-error: true
        with:
          sarif_file: zap_report.sarif
          wait-for-processing: true

      - name: Check ZAP scan result
        id: check_zap_scan
        if: always()
        run: |
          # ZAPã‚¹ã‚­ãƒ£ãƒ³ãŒå®Ÿè¡Œã•ã‚ŒãŸã‹ç¢ºèªï¼ˆrulesãƒ•ã‚¡ã‚¤ãƒ«ã®æœ‰ç„¡ã§åˆ†å²ï¼‰
          if [ "${{ steps.zap_scan_with_rules.outcome }}" == "success" ] || [ "${{ steps.zap_scan_with_rules.outcome }}" == "failure" ]; then
            echo "scan_executed=true" >> $GITHUB_OUTPUT
            echo "scan_outcome=${{ steps.zap_scan_with_rules.outcome }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.zap_scan_no_rules.outcome }}" == "success" ] || [ "${{ steps.zap_scan_no_rules.outcome }}" == "failure" ]; then
            echo "scan_executed=true" >> $GITHUB_OUTPUT
            echo "scan_outcome=${{ steps.zap_scan_no_rules.outcome }}" >> $GITHUB_OUTPUT
          else
            echo "scan_executed=false" >> $GITHUB_OUTPUT
            echo "scan_outcome=skipped" >> $GITHUB_OUTPUT
            echo "Error: ZAP scan was not executed"
            exit 1
          fi

      - name: Parse ZAP scan results
        id: parse_results
        if: always() && steps.check_zap_scan.outputs.scan_executed == 'true' && steps.check_zap_files.outputs.json_exists == 'true'
        run: |
          # zap_report.jsonã‹ã‚‰çµæžœã‚’è§£æž
          if [ -f zap_report.json ]; then
            # é‡å¤§ãªå•é¡Œã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            HIGH_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 3)] | length' zap_report.json || echo "0")
            MEDIUM_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 2)] | length' zap_report.json || echo "0")
            LOW_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 1)] | length' zap_report.json || echo "0")
            INFO_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 0)] | length' zap_report.json || echo "0")
            
            echo "high_issues=$HIGH_ISSUES" >> $GITHUB_OUTPUT
            echo "medium_issues=$MEDIUM_ISSUES" >> $GITHUB_OUTPUT
            echo "low_issues=$LOW_ISSUES" >> $GITHUB_OUTPUT
            echo "info_issues=$INFO_ISSUES" >> $GITHUB_OUTPUT
            
            # é‡å¤§ãªå•é¡ŒãŒã‚ã‚‹å ´åˆã¯å¤±æ•—ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            if [ "$HIGH_ISSUES" -gt 0 ]; then
              echo "has_critical_issues=true" >> $GITHUB_OUTPUT
              echo "scan_passed=false" >> $GITHUB_OUTPUT
            else
              echo "has_critical_issues=false" >> $GITHUB_OUTPUT
              echo "scan_passed=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "Error: zap_report.json not found. ZAP scan may have failed."
            echo "high_issues=0" >> $GITHUB_OUTPUT
            echo "medium_issues=0" >> $GITHUB_OUTPUT
            echo "low_issues=0" >> $GITHUB_OUTPUT
            echo "info_issues=0" >> $GITHUB_OUTPUT
            echo "has_critical_issues=false" >> $GITHUB_OUTPUT
            echo "scan_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Create or update PR comment with detailed report
        if: always() && steps.check_sarif.outputs.exists == 'true' && github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body-path: zap_report.md
          edit-mode: replace
          comment-tag: zap-scan-results-preview

      - name: Post scan summary comment to PR
        if: always() && github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            ## ðŸ”’ OWASP ZAP Security Scan Results (Preview)
            
            **Deployment URL:** ${{ needs.deploy-preview.outputs.url }}
            
            ### Scan Summary
            - ðŸ”´ **High Risk Issues:** ${{ steps.parse_results.outputs.high_issues }}
            - ðŸŸ¡ **Medium Risk Issues:** ${{ steps.parse_results.outputs.medium_issues }}
            - ðŸŸ  **Low Risk Issues:** ${{ steps.parse_results.outputs.low_issues }}
            - ðŸ”µ **Info Issues:** ${{ steps.parse_results.outputs.info_issues }}
            
            ${{ steps.parse_results.outputs.has_critical_issues == 'true' && '### âš ï¸ **WARNING: Critical security issues detected!**' || '### âœ… No critical security issues detected' }}
            
            ${{ steps.check_sarif.outputs.exists == 'true' && '**Detailed Report:** See the full report in the comment above or check the workflow artifacts for HTML/JSON reports.' || '**Note:** Detailed report is not available. Check the workflow artifacts for scan results.' }}
            
            ---
            *This scan was automatically triggered by the preview deployment.*
          edit-mode: replace
          comment-tag: zap-scan-summary-preview

      - name: Post preview scan summary
        if: always()
        run: |
          echo "## ðŸ”’ OWASP ZAP Security Scan Results (Preview)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment URL:** ${{ needs.deploy-preview.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”´ **High Risk Issues:** ${{ steps.parse_results.outputs.high_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŸ¡ **Medium Risk Issues:** ${{ steps.parse_results.outputs.medium_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŸ  **Low Risk Issues:** ${{ steps.parse_results.outputs.low_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”µ **Info Issues:** ${{ steps.parse_results.outputs.info_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.parse_results.outputs.has_critical_issues }}" == "true" ]; then
            echo "### âš ï¸ **WARNING: Critical security issues detected!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
              echo "âš ï¸ Production deployment will be skipped due to security issues in preview environment." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "### âœ… No critical security issues detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
              echo "âœ… Preview scan passed. Production deployment can proceed." >> $GITHUB_STEP_SUMMARY
            fi
          fi

      - name: Fail if critical issues found or scan failed
        if: always()
        run: |
          if [ "${{ steps.check_zap_scan.outputs.scan_executed }}" != "true" ]; then
            echo "Error: ZAP scan was not executed"
            exit 1
          fi
          
          if [ "${{ steps.parse_results.outputs.scan_passed }}" == "false" ]; then
            if [ "${{ steps.parse_results.outputs.has_critical_issues }}" == "true" ]; then
              echo "Critical security issues detected. Failing the workflow."
            else
              echo "ZAP scan failed or report not found. Failing the workflow."
            fi
            exit 1
          fi
          
          echo "ZAP scan completed successfully"

  deploy-production:
    runs-on: ubuntu-latest
    name: Deploy to Vercel Production
    outputs:
      url: ${{ steps.deploy_production.outputs.url }}
      environment: ${{ steps.deploy_production.outputs.environment }}
    needs: [deploy-preview, scan-preview]
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      needs.deploy-preview.result == 'success' &&
      needs.scan-preview.result == 'success' &&
      needs.scan-preview.outputs.scan_passed == 'true'
    env:
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Pull Vercel Environment Information
        run: |
          vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}

      - name: Verify Vercel Configuration
        run: |
          # .vercelãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒä½œæˆã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
          if [ ! -d ".vercel" ]; then
            echo "Error: .vercel directory not found after vercel pull"
            exit 1
          fi
          
          # project.jsonãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
          if [ ! -f ".vercel/project.json" ]; then
            echo "Error: .vercel/project.json not found"
            exit 1
          fi
          
          echo "Vercel configuration verified successfully"
          echo "Project configuration:"
          cat .vercel/project.json

      - name: Build Project Artifacts
        run: |
          vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}

      - name: Deploy to Vercel Production
        id: deploy_production
        run: |
          DEPLOYMENT_OUTPUT=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }})
          echo "$DEPLOYMENT_OUTPUT"
          DEPLOYMENT_URL=$(echo "$DEPLOYMENT_OUTPUT" | grep -o 'https://[^ ]*\.vercel\.app' | head -1)
          
          if [ -z "$DEPLOYMENT_URL" ]; then
            echo "Error: Failed to extract deployment URL from Vercel output"
            exit 1
          fi
          
          echo "url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "environment=production" >> $GITHUB_OUTPUT
          echo "Deployment URL: $DEPLOYMENT_URL"

  scan-production:
    runs-on: ubuntu-latest
    name: OWASP ZAP Security Scan (Production)
    needs: deploy-production
    if: always() && needs.deploy-production.result == 'success'
    permissions:
      contents: read
      issues: write
      security-events: write
      actions: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate deployment URL
        id: validate_url_prod
        env:
          TARGET_URL: ${{ needs.deploy-production.outputs.url }}
        run: |
          if [ -z "$TARGET_URL" ]; then
            echo "Error: Deployment URL is empty"
            exit 1
          fi
          
          if [[ ! "$TARGET_URL" =~ ^https?:// ]]; then
            echo "Error: Invalid URL format: $TARGET_URL"
            exit 1
          fi
          
          echo "Deployment URL validated: $TARGET_URL"

      - name: Wait for deployment to be ready
        env:
          TARGET_URL: ${{ needs.deploy-production.outputs.url }}
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
        run: |
          echo "Waiting for Vercel deployment to be ready..."
          echo "Target URL: $TARGET_URL"
          MAX_RETRIES=30
          RETRY_COUNT=0
          WAIT_INTERVAL=15

          # Vercel Automation Bypassãƒ˜ãƒƒãƒ€ãƒ¼ã‚’è¨­å®š
          if [ -n "$VERCEL_AUTOMATION_BYPASS_SECRET" ]; then
            echo "Using Vercel Automation Bypass header"
          else
            echo "Warning: VERCEL_AUTOMATION_BYPASS_SECRET is not set"
          fi

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if [ -n "$VERCEL_AUTOMATION_BYPASS_SECRET" ]; then
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -H "x-vercel-protection-bypass: $VERCEL_AUTOMATION_BYPASS_SECRET" "$TARGET_URL" || echo "000")
            else
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$TARGET_URL" || echo "000")
            fi
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Deployment is ready! HTTP Status: $HTTP_CODE"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "Connection failed (retry $RETRY_COUNT/$MAX_RETRIES)"
            else
              echo "HTTP Status: $HTTP_CODE (retry $RETRY_COUNT/$MAX_RETRIES)"
            fi
            
            sleep $WAIT_INTERVAL
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done

          echo "Error: Deployment did not become ready after $((MAX_RETRIES * WAIT_INTERVAL)) seconds"
          echo "Last HTTP Status: $HTTP_CODE"
          exit 1

      - name: Check if ZAP rules file exists
        id: check_zap_rules_prod
        run: |
          if [ -f ".zap/rules.tsv" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "ZAP rules file found: .zap/rules.tsv"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "ZAP rules file not found: .zap/rules.tsv (will use default rules)"
          fi

      - name: Build ZAP cmd_options with header injection
        id: build_zap_options_prod
        env:
          VERCEL_AUTOMATION_BYPASS_SECRET: ${{ secrets.VERCEL_AUTOMATION_BYPASS_SECRET }}
        run: |
          BASE_OPTIONS="-a"
          
          if [ -n "$VERCEL_AUTOMATION_BYPASS_SECRET" ]; then
            # ZAPã®replaceræ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’æ³¨å…¥
            REPLACER_CONFIG="-z \"-config replacer.full_list(0).description=auth -config replacer.full_list(0).enabled=true -config replacer.full_list(0).matchtype=REQ_HEADER -config replacer.full_list(0).matchstr=x-vercel-protection-bypass -config replacer.full_list(0).replacement=$VERCEL_AUTOMATION_BYPASS_SECRET\""
            CMD_OPTIONS="$BASE_OPTIONS $REPLACER_CONFIG"
            echo "Using Vercel Automation Bypass header injection"
          else
            CMD_OPTIONS="$BASE_OPTIONS"
            echo "Warning: VERCEL_AUTOMATION_BYPASS_SECRET is not set, skipping header injection"
          fi
          
          echo "cmd_options=$CMD_OPTIONS" >> $GITHUB_OUTPUT
          echo "Built ZAP cmd_options: $CMD_OPTIONS"

      - name: ZAP Baseline Scan (with rules file)
        id: zap_scan_with_rules_prod
        if: steps.check_zap_rules_prod.outputs.exists == 'true'
        uses: zaproxy/action-baseline@v0.12.0
        continue-on-error: true
        with:
          target: ${{ needs.deploy-production.outputs.url }}
          rules_file_name: '.zap/rules.tsv'
          cmd_options: ${{ steps.build_zap_options_prod.outputs.cmd_options }}
          fail_action: false
          allow_issue_writing: false

      - name: ZAP Baseline Scan (without rules file)
        id: zap_scan_no_rules_prod
        if: steps.check_zap_rules_prod.outputs.exists == 'false'
        uses: zaproxy/action-baseline@v0.12.0
        continue-on-error: true
        with:
          target: ${{ needs.deploy-production.outputs.url }}
          cmd_options: ${{ steps.build_zap_options_prod.outputs.cmd_options }}
          fail_action: false
          allow_issue_writing: false

      - name: Check ZAP output files
        id: check_zap_files_prod
        if: always()
        run: |
          echo "Checking for ZAP output files..."
          ls -la
          echo ""
          echo "Files matching *report*:"
          ls -la *report* 2>/dev/null || echo "No files matching *report* found"
          echo ""
          echo "Files matching report_*:"
          ls -la report_* 2>/dev/null || echo "No files matching report_* found"
          echo ""
          echo "Files matching zap_*:"
          ls -la zap_* 2>/dev/null || echo "No files matching zap_* found"
          
          # ZAPã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒç”Ÿæˆã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç¢ºèª
          if [ -f "report_json.json" ]; then
            echo "Found report_json.json, renaming to zap_report.json"
            cp report_json.json zap_report.json
          fi
          if [ -f "report_md.md" ]; then
            echo "Found report_md.md, renaming to zap_report.md"
            cp report_md.md zap_report.md
          fi
          if [ -f "report_html.html" ]; then
            echo "Found report_html.html, renaming to zap_report.html"
            cp report_html.html zap_report.html
          fi
          
          # SARIFãƒ•ã‚¡ã‚¤ãƒ«ã®ç¢ºèª
          if [ -f "zap_report.sarif" ]; then
            echo "sarif_exists=true" >> $GITHUB_OUTPUT
          elif [ -f "report.sarif" ]; then
            echo "Found report.sarif, renaming to zap_report.sarif"
            cp report.sarif zap_report.sarif
            echo "sarif_exists=true" >> $GITHUB_OUTPUT
          else
            echo "sarif_exists=false" >> $GITHUB_OUTPUT
          fi
          
          # JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ç¢ºèª
          if [ -f "zap_report.json" ]; then
            echo "json_exists=true" >> $GITHUB_OUTPUT
          else
            echo "json_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Archive ZAP results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-report-production-${{ github.run_id }}
          path: |
            zap_report.html
            zap_report.json
            zap_report.md
            zap_report.sarif
            report_html.html
            report_json.json
            report_md.md
            report.sarif
          retention-days: 30
          if-no-files-found: ignore

      - name: Upload ZAP results to GitHub Security
        uses: github/codeql-action/upload-sarif@v4
        if: always() && steps.check_zap_files_prod.outputs.sarif_exists == 'true'
        continue-on-error: true
        with:
          sarif_file: zap_report.sarif
          wait-for-processing: true

      - name: Check ZAP scan result
        id: check_zap_scan_prod
        if: always()
        run: |
          # ZAPã‚¹ã‚­ãƒ£ãƒ³ãŒå®Ÿè¡Œã•ã‚ŒãŸã‹ç¢ºèªï¼ˆrulesãƒ•ã‚¡ã‚¤ãƒ«ã®æœ‰ç„¡ã§åˆ†å²ï¼‰
          if [ "${{ steps.zap_scan_with_rules_prod.outcome }}" == "success" ] || [ "${{ steps.zap_scan_with_rules_prod.outcome }}" == "failure" ]; then
            echo "scan_executed=true" >> $GITHUB_OUTPUT
            echo "scan_outcome=${{ steps.zap_scan_with_rules_prod.outcome }}" >> $GITHUB_OUTPUT
          elif [ "${{ steps.zap_scan_no_rules_prod.outcome }}" == "success" ] || [ "${{ steps.zap_scan_no_rules_prod.outcome }}" == "failure" ]; then
            echo "scan_executed=true" >> $GITHUB_OUTPUT
            echo "scan_outcome=${{ steps.zap_scan_no_rules_prod.outcome }}" >> $GITHUB_OUTPUT
          else
            echo "scan_executed=false" >> $GITHUB_OUTPUT
            echo "scan_outcome=skipped" >> $GITHUB_OUTPUT
            echo "Error: ZAP scan was not executed"
            exit 1
          fi

      - name: Parse ZAP scan results
        id: parse_results
        if: always() && steps.check_zap_scan_prod.outputs.scan_executed == 'true' && steps.check_zap_files_prod.outputs.json_exists == 'true'
        run: |
          # zap_report.jsonã‹ã‚‰çµæžœã‚’è§£æž
          if [ -f zap_report.json ]; then
            # é‡å¤§ãªå•é¡Œã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            HIGH_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 3)] | length' zap_report.json || echo "0")
            MEDIUM_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 2)] | length' zap_report.json || echo "0")
            LOW_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 1)] | length' zap_report.json || echo "0")
            INFO_ISSUES=$(jq '[.site[]?.alerts[]? | select(.riskcode == 0)] | length' zap_report.json || echo "0")
            
            echo "high_issues=$HIGH_ISSUES" >> $GITHUB_OUTPUT
            echo "medium_issues=$MEDIUM_ISSUES" >> $GITHUB_OUTPUT
            echo "low_issues=$LOW_ISSUES" >> $GITHUB_OUTPUT
            echo "info_issues=$INFO_ISSUES" >> $GITHUB_OUTPUT
            
            # é‡å¤§ãªå•é¡ŒãŒã‚ã‚‹å ´åˆã¯å¤±æ•—ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
            if [ "$HIGH_ISSUES" -gt 0 ]; then
              echo "has_critical_issues=true" >> $GITHUB_OUTPUT
              echo "scan_passed=false" >> $GITHUB_OUTPUT
            else
              echo "has_critical_issues=false" >> $GITHUB_OUTPUT
              echo "scan_passed=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "Error: zap_report.json not found. ZAP scan may have failed."
            echo "high_issues=0" >> $GITHUB_OUTPUT
            echo "medium_issues=0" >> $GITHUB_OUTPUT
            echo "low_issues=0" >> $GITHUB_OUTPUT
            echo "info_issues=0" >> $GITHUB_OUTPUT
            echo "has_critical_issues=false" >> $GITHUB_OUTPUT
            echo "scan_passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Fail if scan failed
        if: always()
        run: |
          if [ "${{ steps.check_zap_scan_prod.outputs.scan_executed }}" != "true" ]; then
            echo "Error: ZAP scan was not executed"
            exit 1
          fi
          
          if [ "${{ steps.parse_results.outputs.scan_passed }}" == "false" ]; then
            if [ "${{ steps.parse_results.outputs.has_critical_issues }}" == "true" ]; then
              echo "Critical security issues detected in production environment."
            else
              echo "ZAP scan failed or report not found."
            fi
            exit 1
          fi
          
          echo "ZAP scan completed successfully"

      - name: Post production scan summary
        if: always()
        run: |
          echo "## ðŸ”’ OWASP ZAP Security Scan Results (Production)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment URL:** ${{ needs.deploy-production.outputs.url }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”´ **High Risk Issues:** ${{ steps.parse_results.outputs.high_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŸ¡ **Medium Risk Issues:** ${{ steps.parse_results.outputs.medium_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸŸ  **Low Risk Issues:** ${{ steps.parse_results.outputs.low_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ”µ **Info Issues:** ${{ steps.parse_results.outputs.info_issues }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.parse_results.outputs.has_critical_issues }}" == "true" ]; then
            echo "### âš ï¸ **WARNING: Critical security issues detected!**" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âœ… No critical security issues detected" >> $GITHUB_STEP_SUMMARY
          fi

